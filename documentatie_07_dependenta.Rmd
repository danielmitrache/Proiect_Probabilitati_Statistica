```{r, echo=FALSE}
set.seed(8421)
# Incarcam sursa pentru a avea acces la functie, desi o vom redefini in text pentru documentare
if(file.exists("R/07_dependenta.R")) source("R/07_dependenta.R")
```

# 7. Dependența (Cerința 7)

În modelele anterioare, am presupus că timpul de răspuns pentru o încercare este independent de istoric. În realitate, un eșec poate indica o problemă sistemică (ex: supraîncărcare, congestie de rețea), ceea ce crește probabilitatea ca următoarea încercare să dureze mai mult sau să eșueze din nou. Aceasta creează o **dependență** între eșecuri și latența viitoare.

## Implementarea funcției cu dependență

Vom modifica funcția de simulare a unei cereri pentru a include un parametru `factor_latenta`. Mecanismul este următorul:
*   Dacă o încercare eșuează, timpul mediu de procesare (`medie_S`) pentru următoarea încercare este multiplicat cu acest factor.
*   Dacă `factor_latenta > 1.0`, sistemul devine "mai lent" pe măsură ce acumulăm eșecuri (degradare progresivă).

```{r}
#' Simuleaza o cerere cu posibilitatea dependentei intre esecuri si latenta
#' 
#' @param n_max Numarul maxim de incercari
#' @param p_succes Probabilitatea de succes a unei incercari
#' @param medie_S_initial Timpul mediu de procesare initial (fara penalizari)
#' @param backoff_fix Timpul de asteptare intre incercari
#' @param factor_latenta Factorul cu care creste media timpului de raspuns dupa un esec. 
#'                          Daca este 1.0, timpii sunt independenti.
#'                          Daca este > 1.0, sistemul devine mai lent dupa esecuri.
#' 
#' @return Timpul total T
simuleaza_cerere_dependenta <- function(n_max = 3, p_succes = 0.7, medie_S_initial = 150, 
                                        backoff_fix = 50, factor_latenta = 1.0) {
  
  timp_total <- 0
  medie_curenta <- medie_S_initial
  succes <- FALSE
  
  for (i in 1:n_max) {
    # Generam timpul de raspuns S_i
    # Daca factor_latenta > 1 si am avut esecuri anterioare, medie_curenta va fi mai mare
    s_i <- rexp(1, rate = 1/medie_curenta)
    timp_total <- timp_total + s_i
    
    # Verificam succesul
    if (runif(1) < p_succes) {
      succes <- TRUE
      break # Daca am reusit, iesim
    } 
    else {
      # Daca am esuat
      # Adaugam backoff daca mai avem incercari
      if (i < n_max) {
        timp_total <- timp_total + backoff_fix
        
        # Aplicam dependenta: latenta creste pentru urmatoarea incercare
        medie_curenta <- medie_curenta * factor_latenta
      }
    }
  }
  
  return(timp_total)
}
```

## a) Simulare: Independent vs Dependent

Vom simula două scenarii pentru a analiza impactul dependenței asupra timpului total de așteptare ($T$):

1.  **Scenariul Independent:** `factor_latenta = 1.0`. Eșecurile nu afectează performanța serverului pentru reîncercări.
2.  **Scenariul Dependent:** `factor_latenta = 2.0`. După fiecare eșec, timpul mediu de răspuns se dublează (ex: 150ms -> 300ms -> 600ms).

Parametrii comuni:
*   $M = 10000$ simulări
*   $n_{max} = 3$ încercări
*   $p_{succes} = 0.7$

```{r}
set.seed(123)
M <- 10000 

# 1. Simulare timpi independenti
timp_independent <- replicate(M, simuleaza_cerere_dependenta(
  n_max = 3, p_succes = 0.7, medie_S_initial = 150, 
  backoff_fix = 50, factor_latenta = 1.0
))

# 2. Simulare timpi dependenti (latenta se dubleaza la esec)
timp_dependent <- replicate(M, simuleaza_cerere_dependenta(
  n_max = 3, p_succes = 0.7, medie_S_initial = 150, 
  backoff_fix = 50, factor_latenta = 2.0
))
```

### Analiza Statistică

Comparăm media și varianța celor două distribuții. Ne așteptăm ca în cazul dependent, varianța să crească semnificativ deoarece cazurile de eșec repetat vor genera timpi foarte lungi (outlieri extremi).

```{r}
var_indep <- var(timp_independent)
var_dep   <- var(timp_dependent)
mean_indep <- mean(timp_independent)
mean_dep   <- mean(timp_dependent)

df_rezultate <- data.frame(
  Scenariu = c("Independent (Factor=1.0)", "Dependent (Factor=2.0)"),
  Media_T = c(mean_indep, mean_dep),
  Varianta_T = c(var_indep, var_dep)
)

knitr::kable(df_rezultate, digits = 2, caption = "Comparatie Statistici T")
```

### b) Comparație: Independent vs Dependent

Vom suprapune densitățile celor două distribuții pentru a evidenția diferențele.

```{r fig.width=8, fig.height=5}
# Setam limita graficului pentru a cuprinde si cozile lungi ale distributiei dependente
x_max <- quantile(timp_dependent, 0.99) 

# Afisam cazul dependent primul (dispersie mai mare)
plot(density(timp_dependent), 
     col = "red", lwd = 2, 
     xlim = c(0, x_max),
     main = "Distributie Timp Total: Dependent vs Independent",
     xlab = "Timp Total (ms)", 
     ylab = "Densitate")

# Adaugam cazul independent
lines(density(timp_independent), col = "blue", lwd = 2)

legend("topright", 
       legend = c("Dependent (Factor=2.0)", "Independent (Factor=1.0)"),
       col = c("red", "blue"), 
       lwd = 2)
```

**Interpretare:**

*   **Linia Albastră (Independent):** Este mai concentrată în stânga, indicând timpi mai mici și mai predictibili.

*   **Linia Roșie (Dependent):** Este mai aplatizată și se întinde mai mult spre dreapta ("heavy tail"). Aceasta cauzează o varianță mult mai mare și crește riscul ca utilizatorii să experimenteze timpi de așteptare foarte mari în momentele critice ale sistemului.

## c) Concluzii privind riscul și stabilitatea sistemului

Analiza comparativă demonstrează că dependența între eșecuri și latență introduce riscuri majore pentru stabilitatea sistemului:

1.  **Efectul de "Bulgăre de Zăpadă":**  
    Într-un sistem dependent (`factor_latenta > 1`), o degradare temporară a performanței poate declanșa o buclă în care timpul de răspuns crește la nesfârșit. Un eșec inițial crește probabilitatea ca următoarele cereri să dureze mai mult, ceea ce poate duce la timeout-uri și mai multe eșecuri, amplificând latența până la blocarea completă a resurselor.

2.  **Impredictibilitate și SLA (Service Level Agreements):**  
    Deși media timpului de așteptare crește, parametrul critic este **varianța** (sau deviația standard). Coada lungă a distribuției în cazul dependent înseamnă că un procent mic, dar semnificativ de utilizatori, vor experimenta latențe extreme. Acest lucru face imposibilă garantarea unui SLA strict ("99% din cereri se termină sub 500ms").

3.  **Recomandări:**  
    Pentru a menține sistemul stabil, este esențial să anulăm dependența. Acest lucru se poate realiza prin mecanisme precum:
    *   **Circuit Breakers:** Oprirea temporară a cererilor către un serviciu care răspunde greu.
    *   **Jitter:** Adăugarea unei componente aleatoare în timpul de backoff pentru a evita sincronizarea reîncercărilor.
    *   **Load Balancing:** Redistribuirea traficului pentru a evita supraîncărcarea unui singur nod deja lent.
