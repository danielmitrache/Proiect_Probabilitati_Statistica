# 8. Dependența (Cerința 7)

În modelele anterioare am presupus că timpul de răspuns pentru o încercare este independent de istoric. În realitate, un eșec poate indica o problemă de sistem,   ceea ce crește timpul de execuție pentru următoarea încercare. Aceasta creează o **dependență** între eșecuri și latență.

## a) Implementarea funcției pentru o cerere dependentă

Vom modifica funcția de simulare a unei cereri pentru a include un parametru `factor_latenta`. Mecanismul este următorul:

* Dacă o încercare eșuează, timpul mediu de procesare (`medie_S`) pentru următoarea încercare este multiplicat cu acest factor.
* Inițial, `factor_latenta` este egal cu 1, deci sistemul pornește din starea de independent.
* Dacă `factor_latenta > 1.0`, sistemul devine "mai lent" pe măsură ce acumulăm eșecuri (degradare progresivă).

```{r sim_dependenta}
#' Simuleaza o cerere cu posibilitatea dependentei intre esecuri si latenta
#' 
#' @param n_max Numarul maxim de incercari
#' @param p_succes Probabilitatea de succes a unei incercari
#' @param medie_S_initial Timpul mediu de procesare initial (fara penalizari)
#' @param backoff_fix Timpul de asteptare intre incercari
#' @param factor_latenta Factorul cu care creste media timpului de raspuns dupa un esec.
#'                       Daca este 1.0, timpii sunt independenti.
#'                       Daca este > 1.0, sistemul devine mai lent dupa esecuri.
#' 
#' @return Timpul total T
simuleaza_cerere_dependenta <- function(n_max = 3, p_succes = 0.7, medie_S_initial = 150, 
                                        backoff_fix = 50, factor_latenta = 1.0) {
  
  timp_total <- 0
  medie_curenta <- medie_S_initial
  succes <- FALSE
  
  for (i in 1:n_max) {
    # Generam timpul de raspuns S_i
    # Daca factor_latenta > 1 si am avut esecuri anterioare, medie_curenta va fi mai mare
    s_i <- rexp(1, rate = 1/medie_curenta)
    timp_total <- timp_total + s_i
    
    # Verificam succesul
    if (runif(1) < p_succes) {
      succes <- TRUE
      break # Daca am reusit, iesim
    } else {
      # Daca am esuat
      # Adaugam backoff daca mai avem incercari
      if (i < n_max) {
        timp_total <- timp_total + backoff_fix
        
        # Aplicam dependenta: latenta creste pentru urmatoarea incercare
        medie_curenta <- medie_curenta * factor_latenta
      }
    }
  }
  
  return(timp_total)
}
```

## b) Comparație: Independent vs Dependent

Vom simula două scenarii pentru a analiza impactul dependenței asupra timpului total de așteptare ($T$):

1. **Scenariul Independent:** `factor_latenta = 1.0`. Eșecurile nu afectează performanța serverului pentru reîncercări.
2. **Scenariul Dependent:** `factor_latenta = 2.0`. După fiecare eșec, timpul mediu de răspuns se dublează (ex: 150ms -> 300ms -> 600ms).

Parametrii comuni:
* $M = 10000$ simulări
* $n_{max} = 3$ încercări
* $p_{succes} = 0.7$

```{r run_sim_dependenta}
set.seed(123)
M <- 10000 

# 1. Simulare timpi independenti
timp_independent <- replicate(M, simuleaza_cerere_dependenta(
  n_max = 3, p_succes = 0.7, medie_S_initial = 150, 
  backoff_fix = 50, factor_latenta = 1.0
))

# 2. Simulare timpi dependenti (latenta se dubleaza la esec)
timp_dependent <- replicate(M, simuleaza_cerere_dependenta(
  n_max = 3, p_succes = 0.7, medie_S_initial = 150, 
  backoff_fix = 50, factor_latenta = 2.0
))
```

### Analiza Statistică

Comparăm media și varianța celor două distribuții. Ne așteptăm ca în cazul dependent, varianța să crească semnificativ deoarece cazurile de eșec repetat vor genera timpi foarte lungi.

```{r stats_dependenta}
var_indep <- var(timp_independent)
var_dep   <- var(timp_dependent)
mean_indep <- mean(timp_independent)
mean_dep   <- mean(timp_dependent)

df_rezultate <- data.frame(
  Scenariu = c("Independent (Factor=1.0)", "Dependent (Factor=2.0)"),
  Media_T = c(mean_indep, mean_dep),
  Varianta_T = c(var_indep, var_dep)
)

knitr::kable(df_rezultate, digits = 2, caption = "Comparatie T")
```

### Vizualizare Grafică

Vom suprapune densitățile celor două distribuții pentru a evidenția diferențele.

```{r plot_dependenta, fig.width=8, fig.height=5, fig.align='center'}
# Setam limita graficului pentru a cuprinde si cozile lungi ale distributiei dependente
x_max <- quantile(timp_dependent, 0.99) 

# Afisam cazul dependent primul (dispersie mai mare)
plot(density(timp_dependent), 
     col = "red", lwd = 2, 
     xlim = c(0, x_max),
     main = "Distributie Timp Total: Dependent vs Independent",
     xlab = "Timp Total (ms)", 
     ylab = "Densitate")

# Adaugam cazul independent
lines(density(timp_independent), col = "blue", lwd = 2)

legend("topright", 
       legend = c("Dependent (Factor=2.0)", "Independent (Factor=1.0)"),
       col = c("red", "blue"), 
       lwd = 2)
```

**Interpretare:**

* **Linia Albastră (Independent):** Este mai concentrată în stânga, indicând timpi mai mici și mai predictibili.
* **Linia Roșie (Dependent):** Este mai aplatizată și se întinde mai mult spre dreapta. Aceasta cauzează o varianță mult mai mare și crește riscul ca utilizatorii să experimenteze timpi de așteptare foarte mari în momentele critice ale sistemului.
