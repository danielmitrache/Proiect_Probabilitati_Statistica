```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# In proiect, fisierele sunt in folderul R/
# (asigura-te ca numele fisierelor respecta exact literele mari/mici)
source("R/03_evenimente.r")
source("R/04_bivarianta_NF.R")
```

# 5. Variabile aleatoare bidimensionale discrete (Cerința 4)

În această secțiune considerăm variabila bidimensională **(N, F)**, unde:

\\begin{itemize}
  \\item **N** = numărul total de încercări (retry-uri + prima încercare)
  \\item **F** = numărul de eșecuri (failures) produse pe parcursul unei cereri
\\end{itemize}

Observație importantă: în modelul de retry, **F nu este o variabilă independentă față de N**, deoarece este determinată de relația logică dintre **N** și indicatorul de succes final **I**:
- dacă cererea reușește la încercarea N (I=1) \\(\\Rightarrow\\) au existat **N-1** eșecuri înainte, deci \\(F=N-1\\)
- dacă cererea eșuează complet (I=0) \\(\\Rightarrow\\) toate încercările sunt eșecuri, deci \\(F=N\\)

## Implementarea simulării (N, F)

Funcția `simuleaza_NF_din_ex3` este un *wrapper* peste `simuleaza_o_cerere` (definită la Cerința 3) și construiește coloana **F** plecând de la (N, I).

```{r}
print(simuleaza_NF_din_ex3)
```

## a) Distribuția comună empirică

Simulăm un eșantion mare \\(M=100000\\) și estimăm distribuția comună prin frecvențe relative.

```{r}
set.seed(42)

M <- 100000
n_max <- 3
p_succes <- 0.7
t_0 <- 400
medie_S <- 150
backoff_fix <- 50

df_NF <- simuleaza_NF_din_ex3(
  M = M, n_max = n_max, p_succes = p_succes,
  t_0 = t_0, medie_S = medie_S, backoff_fix = backoff_fix
)

tab_NF <- table(df_NF$N, df_NF$F)       # frecvente absolute
prob_NF <- prop.table(tab_NF)           # probabilitati empirice

knitr::kable(tab_NF, caption = "Distribuția comună (frecvențe) pentru (N, F)")
knitr::kable(round(prob_NF, 4), caption = "Distribuția comună empirică P(N, F)")
```

## b) Distribuțiile marginale

Marginalele se obțin prin sumare pe linii/coloane ale distribuției comune.

```{r}
marg_N <- margin.table(prob_NF, 1)  # P(N=n)
marg_F <- margin.table(prob_NF, 2)  # P(F=f)

df_marg <- data.frame(
  Valoare = as.integer(names(marg_N)),
  P_N = as.numeric(marg_N)
)
knitr::kable(df_marg, digits = 4, caption = "Distribuția marginală P(N=n)")

df_marg2 <- data.frame(
  Valoare = as.integer(names(marg_F)),
  P_F = as.numeric(marg_F)
)
knitr::kable(df_marg2, digits = 4, caption = "Distribuția marginală P(F=f)")
```

## c) Test empiric de independență

Aplicăm un test \\(\\chi^2\\) pe tabelul de contingență (cu p-value simulat). Ipoteza nulă: **N și F sunt independente**.

```{r}
test_ind <- chisq.test(tab_NF, simulate.p.value = TRUE, B = 2000)
```

## d) Vizualizare (heatmap + mosaicplot) și interpretare

```{r}
prob_mat <- as.matrix(prob_NF)
x_vals <- as.numeric(rownames(prob_mat)) # N
y_vals <- as.numeric(colnames(prob_mat)) # F

par(mfrow = c(1, 2))

# Heatmap (probabilitati empirice)
image(
  x = x_vals, y = y_vals, z = t(prob_mat),
  xlab = "N (nr. încercări)", ylab = "F (nr. eșecuri)",
  main = "Heatmap: P(N,F) (empiric)",
  axes = FALSE
)
axis(1, at = x_vals, labels = x_vals)
axis(2, at = y_vals, labels = y_vals)

# Mosaicplot (frecvente)
mosaicplot(
  tab_NF,
  main = "Mosaicplot: frecvențe (N,F)",
  xlab = "N", ylab = "F"
)

par(mfrow = c(1, 1))
```

**Interpretare:** ne așteptăm ca testul de independență să respingă independența, deoarece **F este aproape determinată de N** (prin relația \\(F=N-1\\) la succes și \\(F=N\\) la eșec final). Consecința: numărul de retry-uri controlează direct numărul de eșecuri, deci variabilele sunt dependente în modelul nostru.
